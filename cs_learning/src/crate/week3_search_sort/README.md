# Week 3-4: 探索とソートアルゴリズム

## 🎯 学習目標

- 線形探索と二分探索の違いを理解し、実装できる
- 各ソートアルゴリズムの特性と計算量を理解する
- Big O記法で計算量を分析できる
- 問題に応じて適切なアルゴリズムを選択できる
- アルゴリズムの安定性と空間計算量を理解する

## 📚 重要な概念

### 1. 計算量（Big O記法）

**Big O記法**は、アルゴリズムの効率を表す数学的表記法です。

```
O(1)      : 定数時間    - 配列のインデックスアクセス
O(log n)  : 対数時間    - 二分探索
O(n)      : 線形時間    - 線形探索、単純なループ
O(n log n): 線形対数時間 - 効率的なソート（マージ、クイック）
O(n²)     : 二次時間    - 単純なソート（バブル、挿入）
O(2^n)    : 指数時間    - 再帰的フィボナッチ（最適化なし）
O(n!)     : 階乗時間    - 巡回セールスマン問題（全探索）
```

**視覚的な比較**（n = 100の場合）:
```
O(1)      : 1回
O(log n)  : 7回       (log₂ 100 ≈ 6.64)
O(n)      : 100回
O(n log n): 664回
O(n²)     : 10,000回
O(2^n)    : 1.27 × 10³⁰回 (実用不可能)
```

**計算量の種類**:
- **時間計算量**: 実行時間（操作回数）
- **空間計算量**: 使用メモリ量
- **最良ケース**: 最も効率的な入力
- **平均ケース**: 典型的な入力
- **最悪ケース**: 最も非効率な入力

### 2. 探索アルゴリズム

#### 2.1 線形探索（Linear Search）

**概念**: 先頭から順番に探す最も単純な探索

```rust
[3, 1, 4, 1, 5, 9, 2, 6] から 5 を探す

Step 1: 3 == 5? No
Step 2: 1 == 5? No
Step 3: 4 == 5? No
Step 4: 1 == 5? No
Step 5: 5 == 5? Yes! → 見つかった（index 4）
```

**特徴**:
- 時間計算量: O(n)
- 空間計算量: O(1)
- データがソート済みかどうかは不要
- 小規模データや未ソートデータに適している

#### 2.2 二分探索（Binary Search）

**概念**: ソート済み配列を半分ずつに分けて探索

```rust
[1, 2, 3, 4, 5, 6, 7, 8, 9] から 6 を探す

Step 1: 中央 (5) と比較
        [1, 2, 3, 4, |5| 6, 7, 8, 9]
        6 > 5 → 右半分を探索

Step 2: 中央 (7) と比較
        [6, |7|, 8, 9]
        6 < 7 → 左半分を探索

Step 3: 中央 (6) と比較
        [|6|]
        6 == 6 → 見つかった！
```

**特徴**:
- 時間計算量: O(log n)
- 空間計算量: O(1)（反復版）、O(log n)（再帰版、スタック使用）
- **前提条件**: データが**ソート済み**であること
- 大規模データの探索に効率的

**なぜ O(log n) なのか？**
毎回データを半分にするため、n個の要素を持つ配列で必要な比較回数は：
```
n → n/2 → n/4 → n/8 → ... → 1
```
これを式にすると：`2^k = n` → `k = log₂ n`

### 3. ソートアルゴリズム

#### 3.1 バブルソート（Bubble Sort）

**概念**: 隣接する要素を比較し、順番が逆なら交換

```rust
[5, 2, 8, 1, 9]

Pass 1:
[5, 2, 8, 1, 9] → [2, 5, 8, 1, 9]  (5と2を交換)
[2, 5, 8, 1, 9] → [2, 5, 8, 1, 9]  (5と8はそのまま)
[2, 5, 8, 1, 9] → [2, 5, 1, 8, 9]  (8と1を交換)
[2, 5, 1, 8, 9] → [2, 5, 1, 8, 9]  (8と9はそのまま)
→ 最大値(9)が最後に移動

Pass 2:
[2, 5, 1, 8, 9] → [2, 1, 5, 8, 9]  (5と1を交換)
→ 次に大きい値(8)が正しい位置に

... 続く
```

**特徴**:
- 時間計算量: O(n²)
- 空間計算量: O(1)
- 安定ソート: 同じ値の相対順序が保たれる
- シンプルだが非効率

#### 3.2 選択ソート（Selection Sort）

**概念**: 未ソート部分から最小値を見つけて先頭に移動

```rust
[5, 2, 8, 1, 9]

Step 1: 最小値(1)を見つけて先頭と交換
        [1, 2, 8, 5, 9]
        ↑ソート済み

Step 2: 残りから最小値(2)を見つけて2番目と交換
        [1, 2, 8, 5, 9]
        ↑  ↑ソート済み

Step 3: 残りから最小値(5)を見つけて3番目と交換
        [1, 2, 5, 8, 9]
        ↑  ↑  ↑ソート済み

... 続く
```

**特徴**:
- 時間計算量: O(n²)
- 空間計算量: O(1)
- **不安定ソート**: 同じ値の相対順序が変わる可能性がある
- 交換回数が少ない（最大n-1回）

#### 3.3 挿入ソート（Insertion Sort）

**概念**: 要素を1つずつ取り出し、ソート済み部分の適切な位置に挿入

```rust
[5, 2, 8, 1, 9]

Step 1: [5] | 2, 8, 1, 9
        2を挿入 → [2, 5] | 8, 1, 9

Step 2: [2, 5] | 8, 1, 9
        8を挿入 → [2, 5, 8] | 1, 9

Step 3: [2, 5, 8] | 1, 9
        1を挿入 → [1, 2, 5, 8] | 9

Step 4: [1, 2, 5, 8] | 9
        9を挿入 → [1, 2, 5, 8, 9]
```

**特徴**:
- 時間計算量: O(n²)（最悪）、O(n)（最良：ソート済み）
- 空間計算量: O(1)
- 安定ソート
- **ほぼソート済みデータに効率的**
- オンラインアルゴリズム（データを受け取りながらソート可能）

#### 3.4 マージソート（Merge Sort）

**概念**: 分割統治法。配列を半分に分割し、ソートしてマージ

```rust
[5, 2, 8, 1, 9, 3, 7, 4]

分割フェーズ:
[5, 2, 8, 1, 9, 3, 7, 4]
     ↓
[5, 2, 8, 1]  [9, 3, 7, 4]
     ↓             ↓
[5, 2] [8, 1]  [9, 3] [7, 4]
  ↓      ↓       ↓      ↓
[5][2] [8][1]  [9][3] [7][4]

マージフェーズ:
[2, 5] [1, 8]  [3, 9] [4, 7]
     ↓             ↓
[1, 2, 5, 8]  [3, 4, 7, 9]
          ↓
[1, 2, 3, 4, 5, 7, 8, 9]
```

**特徴**:
- 時間計算量: O(n log n)（すべてのケース）
- 空間計算量: O(n)（追加の配列が必要）
- 安定ソート
- **予測可能な性能**（最悪ケースでもO(n log n)）
- 外部ソート（大規模データ）に適している

**なぜ O(n log n) なのか？**
- 分割: log n 回（毎回半分にする）
- マージ: 各レベルで O(n) の操作
- 合計: O(n) × O(log n) = O(n log n)

#### 3.5 クイックソート（Quick Sort）

**概念**: ピボットを選び、それより小さい要素と大きい要素に分割

```rust
[5, 2, 8, 1, 9, 3, 7, 4]  ピボット: 4

Step 1: 4を基準に分割
        [2, 1, 3] | 4 | [5, 8, 9, 7]
         小さい    中央   大きい

Step 2: 左側をソート [2, 1, 3]  ピボット: 3
        [1, 2] | 3

        右側をソート [5, 8, 9, 7]  ピボット: 7
        [5] | 7 | [8, 9]

Step 3: 結合
        [1, 2, 3, 4, 5, 7, 8, 9]
```

**特徴**:
- 時間計算量: 平均 O(n log n)、最悪 O(n²)
- 空間計算量: O(log n)（再帰のスタック）
- **不安定ソート**
- **実用的には最速**（キャッシュ効率が良い）
- ピボット選択が重要

**ピボット選択戦略**:
- 最初/最後の要素: シンプルだが、ソート済みデータで最悪ケース
- 中央値: 最良だが計算コストが高い
- ランダム: 平均的に良い性能
- 3つの中央値（median-of-three）: 実用的

#### 3.6 ヒープソート（Heap Sort）

**概念**: ヒープ（二分木の一種）を使ってソート

```rust
[5, 2, 8, 1, 9]

Step 1: 最大ヒープを構築
           9
         /   \
        5     8
       / \
      1   2

Step 2: 最大値(9)を取り出し、最後と交換
           2
         /   \
        5     8     | 9
       /
      1

Step 3: ヒープを再構築し、繰り返す
           8
         /   \
        5     2     | 9
       /
      1

... 続く

最終: [1, 2, 5, 8, 9]
```

**特徴**:
- 時間計算量: O(n log n)（すべてのケース）
- 空間計算量: O(1)（インプレース）
- **不安定ソート**
- マージソートより少ないメモリ使用
- キャッシュ効率は悪い

### 4. ソートアルゴリズムの比較

| アルゴリズム | 最良 | 平均 | 最悪 | 空間 | 安定 | 特徴 |
|------------|------|------|------|------|------|------|
| **バブル** | O(n²) / O(n)* | O(n²) | O(n²) | O(1) | ✅ | シンプル、教育用 |
| **選択** | O(n²) | O(n²) | O(n²) | O(1) | ❌ | 交換回数少ない |
| **挿入** | O(n) | O(n²) | O(n²) | O(1) | ✅ | ほぼソート済みに強い |
| **マージ** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | 予測可能な性能 |
| **クイック** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | 実用的に最速 |
| **ヒープ** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | インプレース |

\* 早期終了最適化を実装した場合のみ O(n)。基本実装は O(n²)

### 5. アルゴリズムの選択指針

**データサイズ**:
- **小規模（n < 50）**: 挿入ソート（シンプル、オーバーヘッド少）
- **中規模**: クイックソート
- **大規模**: マージソートまたはクイックソート

**データの特性**:
- **ほぼソート済み**: 挿入ソート O(n)
- **逆順**: クイックソート（ピボット選択に注意）
- **ランダム**: クイックソート

**制約**:
- **追加メモリ不可**: ヒープソート、クイックソート
- **安定性必須**: マージソート、挿入ソート
- **最悪ケースの保証**: マージソート、ヒープソート

**実用的な選択**:
- **標準ライブラリ**: 通常はIntroSort（クイック + ヒープ + 挿入のハイブリッド）
- **Rustの`sort()`**: TimSort（マージ + 挿入のハイブリッド）
- **Rustの`sort_unstable()`**: パターンマッチング版クイックソート

## 💻 実装課題

### 課題1: 探索アルゴリズム

#### 1.1 線形探索
```rust
fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize>
```
配列から要素を線形探索で見つける。

#### 1.2 二分探索（反復版）
```rust
fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize>
```
ソート済み配列から要素を二分探索で見つける（ループ使用）。

#### 1.3 二分探索（再帰版）
```rust
fn binary_search_recursive<T: Ord>(arr: &[T], target: &T) -> Option<usize>
```
ソート済み配列から要素を二分探索で見つける（再帰使用）。

### 課題2: 基本ソートアルゴリズム（O(n²)）

#### 2.1 バブルソート
```rust
fn bubble_sort<T: Ord>(arr: &mut [T])
```
**最適化版も実装**: 交換が発生しなかったら終了

#### 2.2 選択ソート
```rust
fn selection_sort<T: Ord>(arr: &mut [T])
```

#### 2.3 挿入ソート
```rust
fn insertion_sort<T: Ord>(arr: &mut [T])
```

### 課題3: 高度なソートアルゴリズム（O(n log n)）

#### 3.1 マージソート
```rust
fn merge_sort<T: Ord + Clone>(arr: &mut [T])
```
**ヒント**:
- 再帰的に分割
- マージ時に一時的な配列が必要
- 2つのソート済み配列をマージする補助関数を作る

#### 3.2 クイックソート
```rust
fn quick_sort<T: Ord>(arr: &mut [T])
```
**ヒント**:
- ピボットを選択（最初、最後、中央、ランダムなど）
- パーティション操作（ピボットより小さい要素を左、大きい要素を右）
- 再帰的にソート

#### 3.3 ヒープソート（チャレンジ課題）
```rust
fn heap_sort<T: Ord>(arr: &mut [T])
```
**ヒント**:
- 最大ヒープを構築
- ルートと最後の要素を交換
- ヒープサイズを減らして再構築

### 課題4: 応用問題

#### 4.1 計算量の測定
各ソートアルゴリズムの実行時間を測定し、グラフ化する

```rust
fn benchmark_sorts()
```

#### 4.2 安定性のテスト
ソートアルゴリズムが安定かどうかをテストする

```rust
struct Person {
    name: String,
    age: u32,
}

// 年齢でソートして、同じ年齢の場合に名前の順序が保たれるか確認
```

#### 4.3 カスタム比較関数
カスタム比較関数を使ったソート

```rust
fn sort_by<T, F>(arr: &mut [T], compare: F)
where
    F: Fn(&T, &T) -> std::cmp::Ordering
```

## 🧪 テストケース例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_linear_search() {
        let arr = vec![5, 2, 8, 1, 9];
        assert_eq!(linear_search(&arr, &8), Some(2));
        assert_eq!(linear_search(&arr, &10), None);
    }

    #[test]
    fn test_binary_search() {
        let arr = vec![1, 2, 5, 8, 9];
        assert_eq!(binary_search(&arr, &5), Some(2));
        assert_eq!(binary_search(&arr, &10), None);
    }

    #[test]
    fn test_bubble_sort() {
        let mut arr = vec![5, 2, 8, 1, 9];
        bubble_sort(&mut arr);
        assert_eq!(arr, vec![1, 2, 5, 8, 9]);
    }

    #[test]
    fn test_merge_sort() {
        let mut arr = vec![5, 2, 8, 1, 9, 3, 7, 4];
        merge_sort(&mut arr);
        assert_eq!(arr, vec![1, 2, 3, 4, 5, 7, 8, 9]);
    }

    #[test]
    fn test_sort_empty_array() {
        let mut arr: Vec<i32> = vec![];
        bubble_sort(&mut arr);
        assert_eq!(arr, vec![]);
    }

    #[test]
    fn test_sort_single_element() {
        let mut arr = vec![42];
        quick_sort(&mut arr);
        assert_eq!(arr, vec![42]);
    }

    #[test]
    fn test_sort_already_sorted() {
        let mut arr = vec![1, 2, 3, 4, 5];
        insertion_sort(&mut arr);
        assert_eq!(arr, vec![1, 2, 3, 4, 5]);
    }

    #[test]
    fn test_sort_reverse_sorted() {
        let mut arr = vec![5, 4, 3, 2, 1];
        merge_sort(&mut arr);
        assert_eq!(arr, vec![1, 2, 3, 4, 5]);
    }

    #[test]
    fn test_sort_with_duplicates() {
        let mut arr = vec![3, 1, 4, 1, 5, 9, 2, 6, 5];
        quick_sort(&mut arr);
        assert_eq!(arr, vec![1, 1, 2, 3, 4, 5, 5, 6, 9]);
    }

    #[test]
    fn test_stability() {
        #[derive(Debug, Clone, PartialEq, Eq)]
        struct Item {
            key: i32,
            id: usize,
        }

        impl PartialOrd for Item {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                Some(self.cmp(other))
            }
        }

        impl Ord for Item {
            fn cmp(&self, other: &Self) -> std::cmp::Ordering {
                self.key.cmp(&other.key)
            }
        }

        let mut arr = vec![
            Item { key: 3, id: 1 },
            Item { key: 1, id: 2 },
            Item { key: 3, id: 3 },
            Item { key: 2, id: 4 },
        ];

        // 安定ソートの場合、同じkeyのidの順序が保たれる
        insertion_sort(&mut arr);
        assert_eq!(arr[2].id, 1); // 最初の3
        assert_eq!(arr[3].id, 3); // 2番目の3
    }
}
```

## 🔍 デバッグのヒント

1. **配列のインデックスエラー**: 境界チェックを丁寧に
2. **無限ループ**: 二分探索やクイックソートで終了条件を確認
3. **スタックオーバーフロー**: 再帰の深さに注意（大きな配列で発生）
4. **性能測定**: `cargo bench`や`std::time::Instant`を使用

## 📊 計算量の可視化

実装したら、以下のようなベンチマークを取ってグラフ化してみましょう：

```rust
use std::time::Instant;

fn benchmark() {
    let sizes = vec![10, 100, 1000, 10000];

    for size in sizes {
        let mut arr: Vec<i32> = (0..size).rev().collect(); // 逆順

        let start = Instant::now();
        bubble_sort(&mut arr);
        let duration = start.elapsed();

        println!("Size: {}, Time: {:?}", size, duration);
    }
}
```

## 📖 追加学習リソース

- [Sorting Algorithm Animations](https://www.toptal.com/developers/sorting-algorithms)
- [VisuAlgo - Sorting](https://visualgo.net/en/sorting)
- [Rust Algorithm Club](https://github.com/EbTech/rust-algorithms)
- ["Introduction to Algorithms" (CLRS)](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)

## 🎓 理解度確認問題

次のステップに進む前に、以下の問題に答えて理解度を確認してください。

### カテゴリ1: 計算量の理解

#### 問題1.1: 二分探索の計算量導出
二分探索がO(log n)である理由を数式で説明してください。

<details>
<summary>解答例</summary>

二分探索は毎回探索範囲を半分にします：
- 1回目: n 個
- 2回目: n/2 個
- 3回目: n/4 個
- k回目: n/2^k 個

探索が終了するのは要素が1個になったとき：
```
n/2^k = 1
n = 2^k
k = log₂ n
```

したがって、最大比較回数は log₂ n 回 → **O(log n)**
</details>

#### 問題1.2: バブルソートの計算量導出
バブルソートの最悪ケースがO(n²)である理由を、比較回数から導出してください。

<details>
<summary>解答例</summary>

配列長 n の場合の比較回数：
- 1パス目: n-1 回
- 2パス目: n-2 回
- 3パス目: n-3 回
- ...
- (n-1)パス目: 1 回

合計比較回数：
```
(n-1) + (n-2) + ... + 1 = n(n-1)/2 = (n² - n)/2
```

最高次の項は n² → **O(n²)**
</details>

#### 問題1.3: マージソートの計算量導出
マージソートがすべてのケースでO(n log n)である理由を説明してください。

<details>
<summary>解答例</summary>

**分割フェーズ**:
- 配列を半分ずつ分割していく
- 1個になるまで分割 → 深さ = log₂ n

**マージフェーズ**:
- 各レベルで全要素を1回ずつ処理 → O(n)
- レベル数 = log₂ n

**合計**: O(n) × log₂ n = **O(n log n)**

入力データに関わらず分割とマージの回数は同じため、最良・平均・最悪すべてO(n log n)
</details>

#### 問題1.4: クイックソートの最悪ケース
クイックソートの最悪ケースがO(n²)になる状況と、その理由を説明してください。

<details>
<summary>解答例</summary>

**最悪ケース**: 常に最小値または最大値がピボットに選ばれる場合

例：ソート済み配列 `[1,2,3,4,5]` で最後の要素をピボットとする場合
- 1回目: ピボット=5 → 分割: [1,2,3,4] | [5]
- 2回目: ピボット=4 → 分割: [1,2,3] | [4]
- ...

毎回1要素ずつしか減らない → 再帰深さ = n

各レベルで O(n) の処理 → **O(n²)**

**回避策**: ランダムピボット、median-of-three
</details>

#### 問題1.5: 空間計算量の比較
以下のアルゴリズムの空間計算量を答え、その理由を説明してください：
- バブルソート
- マージソート
- クイックソート

<details>
<summary>解答例</summary>

| アルゴリズム | 空間計算量 | 理由 |
|------------|-----------|------|
| **バブルソート** | O(1) | インプレース（追加配列不要） |
| **マージソート** | O(n) | マージ用の一時配列が必要 |
| **クイックソート** | O(log n) | 再帰呼び出しのスタック（平均ケース） |

</details>

---

### カテゴリ2: アルゴリズムの特性理解

#### 問題2.1: 安定ソートの定義
安定ソートとは何か説明し、以下のアルゴリズムが安定か不安定か答えてください：
- バブルソート
- 選択ソート
- 挿入ソート
- マージソート
- クイックソート

<details>
<summary>解答例</summary>

**安定ソートの定義**: 同じ値の要素の相対順序が、ソート後も保たれる性質

| アルゴリズム | 安定性 | 理由 |
|------------|-------|------|
| **バブルソート** | ✅ 安定 | 等しい要素は交換しない（`arr[j] > arr[j+1]`） |
| **選択ソート** | ❌ 不安定 | 離れた要素を交換するため順序が入れ替わる |
| **挿入ソート** | ✅ 安定 | 等しい要素の前に挿入（`arr[j-1] > arr[j]`） |
| **マージソート** | ✅ 安定 | マージ時に左側を優先すれば安定 |
| **クイックソート** | ❌ 不安定 | パーティション操作で順序が変わる |

**例**（不安定ソートで順序が変わる場合）:
```
入力: [3a, 1, 3b, 2]  (aとbは同じ値3だが異なる要素)
選択ソート後: [1, 2, 3b, 3a]  ← 3aと3bの順序が逆転
```
</details>

#### 問題2.2: 最良ケースの性能
以下のアルゴリズムの最良ケースを説明してください：
- バブルソート（最適化版）
- 挿入ソート

<details>
<summary>解答例</summary>

**バブルソート（最適化版）**:
- 最良ケース: **ソート済み配列**
- 計算量: **O(n)**
- 理由: 1パス目で交換が発生せず早期終了。n-1回の比較のみ。

**挿入ソート**:
- 最良ケース: **ソート済み配列**
- 計算量: **O(n)**
- 理由: 各要素が既に正しい位置にあり、内側ループの比較が1回のみ。

**重要**: バブルソート基本版は最良ケースでもO(n²)（早期終了がないため）
</details>

#### 問題2.3: 選択ソートの特性
選択ソートの交換回数は最大何回か？また、その特性がどのような場面で有利か説明してください。

<details>
<summary>解答例</summary>

**交換回数**: 最大 **n-1 回**

**理由**: 各パスで1回だけ交換する（最小値を見つけてから交換）

**有利な場面**:
1. **書き込みコストが高い環境**（例：EEPROM、フラッシュメモリ）
2. **交換操作が重い要素**（例：大きな構造体）

**比較**: バブルソートは O(n²) 回の交換が発生する可能性がある
</details>

#### 問題2.4: オンラインアルゴリズム
挿入ソートが「オンラインアルゴリズム」と呼ばれる理由を説明してください。

<details>
<summary>解答例</summary>

**オンラインアルゴリズムの定義**: データを受け取りながら逐次処理できるアルゴリズム

**挿入ソートの特性**:
- 左側は常にソート済み
- 新しい要素が来たら、その時点で適切な位置に挿入できる
- すべてのデータが揃う前から処理開始可能

**例**（ストリーミングデータ）:
```
[5] → [2, 5] → [2, 5, 8] → [1, 2, 5, 8] ...
```

**対照**: マージソートやクイックソートは全データが必要
</details>

---

### カテゴリ3: アルゴリズム選択問題

#### 問題3.1: 実践シナリオ1
10万件のほぼソート済みデータをソートする必要があります。どのアルゴリズムを選択すべきか、理由と共に答えてください。

<details>
<summary>解答例</summary>

**推奨**: **挿入ソート** または **TimSort**（Rustの`sort()`）

**理由**:
1. 挿入ソートはほぼソート済みデータで **O(n)** に近い性能
2. 10万件でもO(n)なら現実的に高速
3. 空間計算量がO(1)で追加メモリ不要

**TimSort**: Rustの標準ライブラリが採用。挿入ソートとマージソートのハイブリッドで、ほぼソート済みデータに最適化されている。

**避けるべき**: バブルソート（O(n²)で10万件は遅い）、クイックソート（ほぼソート済みで最悪ケースの可能性）
</details>

#### 問題3.2: 実践シナリオ2
メモリ制約が厳しい組み込みシステムで、1000件のランダムデータをソートします。どのアルゴリズムを選択すべきか？

<details>
<summary>解答例</summary>

**推奨**: **ヒープソート** または **クイックソート**

**理由**:
1. **ヒープソート**:
   - 空間計算量 O(1)（インプレース）
   - 時間計算量 O(n log n)（最悪ケースも保証）
   - メモリ制約に最適
2. **クイックソート**:
   - 空間計算量 O(log n)（スタックのみ）
   - 平均 O(n log n)
   - 実用的に高速

**避けるべき**:
- マージソート（O(n)の追加メモリ必要）
- 挿入ソート（1000件でO(n²)は遅い）
</details>

#### 問題3.3: 実践シナリオ3
安定性が必須の要件で、100万件のデータをソートする必要があります。選択肢を挙げてください。

<details>
<summary>解答例</summary>

**推奨アルゴリズム**:
1. **マージソート** ⭐最適
2. **TimSort**（Rustの`sort()`）
3. 挿入ソート（データ量が多すぎて非現実的）

**理由**:
- **マージソート**:
  - 安定ソート
  - 時間計算量 O(n log n)（最悪ケースも保証）
  - 100万件でも現実的な速度
  - 追加メモリが許容できれば最適
- **TimSort**:
  - 安定ソート
  - 実データでマージソートより高速なことが多い
  - Rustの標準`sort()`が採用

**避けるべき**:
- クイックソート（不安定）
- ヒープソート（不安定）
- バブルソート（O(n²)で100万件は非現実的）
</details>

#### 問題3.4: 実践シナリオ4
重複が多いデータ（例：年齢でソート）で最適なアルゴリズムは？

<details>
<summary>解答例</summary>

**推奨**:
1. **カウンティングソート** ⭐最適（値の範囲が小さい場合）
2. **3-way クイックソート**
3. 通常のクイックソート

**理由**:
- **カウンティングソート**:
  - 時間計算量 O(n + k)（k=値の範囲）
  - 年齢(0-120)のような範囲が小さいデータに最適
  - 非比較ソート
- **3-way クイックソート**:
  - 重複値を効率的に処理
  - ピボットと等しい要素をまとめて処理
  - 重複が多い場合、O(n log k)（k=異なる値の数）

**注意**: カウンティングソートは Week 3-4 の範囲外ですが、実用上重要
</details>

---

### カテゴリ4: 実装の理解（バグ発見）

#### 問題4.1: バブルソートのバグ
以下のバブルソート実装にはバグがあります。どこが間違っているか指摘してください。

```rust
fn bubble_sort_buggy<T: Ord>(arr: &mut [T]) {
    for i in 0..arr.len() - 1 {
        for j in 0..arr.len() - i {  // ← バグ1
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
            }
        }
    }
}
```

<details>
<summary>解答</summary>

**バグ**: `for j in 0..arr.len() - i`

**問題点**:
- `j + 1` が `arr.len()` を超える可能性がある
- `arr.len() = 5, i = 0` のとき、`j` は `0..5` → `j = 4` で `arr[5]` にアクセス（範囲外）

**修正**:
```rust
for j in 0..arr.len() - 1 - i {  // または
for j in 0..arr.len() - i - 1 {
```

**詳細**:
- 内側ループは `j + 1` にアクセスするため、`j` の最大値は `arr.len() - 2` であるべき
- `i` が増えるにつれて末尾の要素はソート済みなので、範囲を縮める
</details>

#### 問題4.2: 選択ソートのバグ
以下の選択ソート実装にはバグがあります。どこが間違っているか指摘してください。

```rust
fn selection_sort_buggy<T: Ord>(arr: &mut [T]) {
    for i in 0..arr.len() - 1 {
        let mut min_idx = i;
        for j in i..arr.len() - 1 {  // ← バグ1
            if arr[j] < arr[min_idx] {
                min_idx = j;
            }
        }
        arr.swap(i, min_idx);
    }
}
```

<details>
<summary>解答</summary>

**バグ**: `for j in i..arr.len() - 1`

**問題点**:
- 最後の要素 `arr[arr.len() - 1]` を検査しない
- 例：`[3, 1, 2]` で `i = 0` のとき、`j` は `0..2` → `j = 0, 1` のみ検査、最後の `2` を見逃す

**修正**:
```rust
for j in (i + 1)..arr.len() {  // または
for j in i..arr.len() {
```

**正しい理解**:
- 未ソート部分 `arr[i..]` 全体から最小値を探す
- `j = i` から始める場合も問題ないが、`(i + 1)` から始める方が効率的（自分自身との比較が不要）
</details>

#### 問題4.3: 二分探索のバグ
以下の二分探索実装にはバグがあります。どこが間違っているか指摘してください。

```rust
fn binary_search_buggy<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();  // ← バグ1

    while left <= right {  // ← バグ2
        let mid = (left + right) / 2;

        if &arr[mid] == target {
            return Some(mid);
        } else if &arr[mid] < target {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    None
}
```

<details>
<summary>解答</summary>

**バグ1**: `let mut right = arr.len()`

**問題点**:
- 配列の有効なインデックスは `0..arr.len() - 1`
- `right = arr.len()` は範囲外

**修正**:
```rust
let mut right = arr.len() - 1;  // または
let mut right = arr.len().saturating_sub(1);  // 空配列対応
```

**バグ2**: `while left <= right` で整数アンダーフロー

**問題点**:
- `right = mid - 1` で `mid = 0` のとき、`right` がアンダーフローする（usizeは符号なし）
- 空配列で `arr.len() - 1` も同様の問題

**修正案1**（範囲を半開区間にする）:
```rust
let mut left = 0;
let mut right = arr.len();

while left < right {  // "<" に変更
    let mid = left + (right - left) / 2;

    if &arr[mid] == target {
        return Some(mid);
    } else if &arr[mid] < target {
        left = mid + 1;
    } else {
        right = mid;  // mid - 1 ではなく mid
    }
}
```

**修正案2**（空配列チェック追加）:
```rust
if arr.is_empty() {
    return None;
}
let mut right = arr.len() - 1;
// ...
```
</details>

---

### カテゴリ5: 応用問題

#### 問題5.1: アルゴリズムの改良
バブルソートの早期終了最適化以外に、どのような最適化が考えられますか？

<details>
<summary>解答例</summary>

**最適化1: Cocktail Shaker Sort（双方向バブルソート）**
- 左から右、右から左の2方向でバブル
- 最小値と最大値を同時に正しい位置に移動
- 特定のケースで高速化

**最適化2: 最後の交換位置を記録**
```rust
let mut last_swap_pos = arr.len() - 1;
for i in 0..arr.len() - 1 {
    let mut new_last_swap = 0;
    for j in 0..last_swap_pos {
        if arr[j] > arr[j + 1] {
            arr.swap(j, j + 1);
            new_last_swap = j;
        }
    }
    last_swap_pos = new_last_swap;
    if last_swap_pos == 0 { break; }
}
```
最後に交換が発生した位置より後ろはソート済みなので、次回はそこまでしか見ない。

**結論**: それでもO(n²)であることに変わりはないため、実用的にはより効率的なアルゴリズムを使うべき。
</details>

#### 問題5.2: ハイブリッドアルゴリズム
IntroSort（クイックソート + ヒープソート + 挿入ソート）の設計思想を説明してください。

<details>
<summary>解答例</summary>

**IntroSortの戦略**: 各アルゴリズムの長所を組み合わせる

**1. メインはクイックソート**
- 平均O(n log n)で実用的に最速
- キャッシュ効率が良い

**2. 再帰深さがlog nを超えたらヒープソートに切り替え**
- クイックソートの最悪ケース（O(n²)）を回避
- ヒープソートは最悪でもO(n log n)保証

**3. 小さい部分配列（n < 16程度）は挿入ソートを使用**
- 小規模データでは挿入ソートが高速（オーバーヘッド少）
- キャッシュ効率が良い

**結果**:
- 平均ケース: クイックソートの速度
- 最悪ケース: O(n log n)保証
- 実装例: C++の `std::sort()`

**Rustの実装**:
- `sort_unstable()`: パターンマッチング版クイックソート
- `sort()`: TimSort（マージ + 挿入のハイブリッド）
</details>

#### 問題5.3: 計算量クラスの関係
以下の計算量を小さい順に並べてください：
`O(n!)`, `O(2^n)`, `O(n²)`, `O(n log n)`, `O(n)`, `O(log n)`, `O(1)`

<details>
<summary>解答</summary>

**小さい順（高速 → 低速）**:
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n) < O(n!)
```

**具体的な数値（n = 20の場合）**:
- O(1): 1
- O(log n): ~4.3
- O(n): 20
- O(n log n): ~86
- O(n²): 400
- O(2^n): 1,048,576
- O(n!): 2,432,902,008,176,640,000

**実用的な境界**:
- O(n²): n < 10,000 程度まで実用的
- O(2^n): n < 30 程度で限界
- O(n!): n < 12 程度で限界
</details>

#### 問題5.4: 下界の証明
比較ソートの理論的下界がΩ(n log n)である理由を説明してください。

<details>
<summary>解答例</summary>

**証明（決定木による）**:

**前提**:
- n 個の要素をソートする場合、n! 通りの順列が可能
- 比較ソートは要素間の大小比較のみで判断

**決定木**:
- 各ノード = 1回の比較
- 葉ノード = 1つの順列（ソート結果）
- 必要な葉ノード数 = n!

**二分木の性質**:
- 高さ h の二分木の葉ノード数 ≤ 2^h

**導出**:
```
2^h ≥ n!
h ≥ log₂(n!)
```

**スターリングの近似**:
```
log₂(n!) ≈ n log₂ n - n log₂ e ≈ n log₂ n
```

したがって、**h = Ω(n log n)**

**結論**:
- どんな比較ソートも最悪ケースでΩ(n log n)回の比較が必要
- マージソート、ヒープソートはこの下界を達成
- 非比較ソート（カウンティング、基数ソート）はこの制約を受けない
</details>

---

### 理解度チェックの目安

以下の基準で次のステップへの準備ができているか判断してください：

| レベル | 基準 | 推奨アクション |
|-------|------|-------------|
| **🟢 準備完了** | カテゴリ1-3の80%以上正答 | 次のWeekへ進んで問題なし |
| **🟡 要復習** | カテゴリ1-3の50-80%正答 | 不正解の分野を復習後、次へ |
| **🔴 理解不足** | カテゴリ1-3の50%未満 | 実装とテストを再度実施 |

**カテゴリ4-5**: 発展的内容のため、次のWeekで学びながら理解を深めても問題ありません。

## ✅ チェックリスト

- [x] 線形探索を実装
- [x] 二分探索（反復版）を実装
- [x] 二分探索（再帰版）を実装
- [x] バブルソートを実装
- [x] 選択ソートを実装
- [x] 挿入ソートを実装
- [ ] マージソートを実装
- [ ] クイックソートを実装
- [ ] ヒープソートを実装（チャレンジ）
- [ ] すべてのテストが通る
- [ ] 各アルゴリズムの計算量を説明できる
- [ ] 適切なアルゴリズムを選択できる
- [x] 安定性と不安定性の違いを理解した
- [ ] ベンチマークを取って性能を比較した

## 🚀 次のステップ

Week 3-4が完了したら、Week 5-6の木構造の基礎に進みましょう！
木構造（特にバイナリサーチツリーやヒープ）は、このWeekで学んだソートアルゴリズムの理解を深めるのに役立ちます。
