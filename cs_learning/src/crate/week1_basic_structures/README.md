# Week 1-2: 基本データ構造

## 🎯 学習目標

- 配列とベクターの違いとメモリレイアウトを理解する
- 連結リストの実装とポインタ操作を習得する
- スタックとキューのLIFO/FIFO特性を理解する
- ハッシュマップの内部動作を理解する

## 📚 重要な概念

### 1. 配列（Array）vs ベクター（Vec）

**配列の特徴:**
- コンパイル時にサイズが確定
- スタックに配置される（小さい場合）
- サイズ変更不可
- `[T; N]`型

**ベクターの特徴:**
- 実行時にサイズ変更可能
- ヒープに配置される
- スタック上にはメタデータが置かれる
    - ポインタ|ベクターのサイズ|cap（ヒープ上に確保済みのメモリ容量 capacity）
- データの参照フロー
    - スタック上のメタデータへのポインタを参照することでヒープに配置されたベクターデータが取得できる
    - （スタック上のメタデータの）ptr -> （ヒープ上の実データ）[0][1][2]
    - 計算量O(1)だが、厳密には スタックメモリ上のvectorのptrへのアクセス＋ヒープからの実データ読み取り = O(2)
        -  ※ただし、ループ内ではポインタはレジスタにキャッシュされるので、実質的には配列とほぼ同じ速度
- cap の必要性は？
    - 要素をpushする際にメモリの再アロケーションを実行するかどうかの判断に利用する
        - len <= cap であれば不要。そうでなければメモリ容量の追加確保が必要のため再アロケーションが必要
- 自動的に容量を拡張
- `Vec<T>`型

**メモリレイアウト:**
```
配列:    [1][2][3][4][5]  ← スタック上の連続メモリ領域

Vector:
  スタック: [ptr|len|cap] (24 bytes)
               ↓
  ヒープ:   [1][2][3][4][5]  ← ヒープ上の連続メモリ領域

どちらもインデックスアクセス: O(1)
（連続配置なのでキャッシュ効率も良い）
```

### 2. 連結リスト（Linked List）

**単方向リスト:**
```
[data|next] -> [data|next] -> [data|next] -> None
```

**特徴:**
- 挿入・削除: O(1)（位置が既知の場合）
- アクセス: O(n)
- メモリ: 各ノードにポインタ分のオーバーヘッド
- 現代のプログラミングではあまり使われない。
    - メモリへの配置が飛び飛びになるため、アクセス速度が遅い(キャッシュ効率の悪さ)
    - リンク用のポインタ（next）が必要でメモリの無駄

**双方向リスト**
各ノードが前後のノードへの参照を持つ線形データ構造  
単方向の連結リストと比較して、要素の追加や削除が扱いやすい点がメリットだが、
前後の参照を持つためポインタが2倍必要であることや実装の複雑であることがデメリット

┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
│ HEAD │───→│ Node │───→│ Node │───→│ TAIL │
│      │    │  10  │    │  20  │    │      │
│      │←───│ prev │←───│ prev │←───│      │
└──────┘    │ next │    │ next │    └──────┘
            └──────┘    └──────┘

**Rustでの実装の難しさ:**
- 所有権システムのため、複数の参照を持つことが難しい
- `Box<T>`、`Rc<T>`、`RefCell<T>`を理解する必要がある

### 3. スタック（Stack）- LIFO

```
    push(3)
    push(2)
    push(1)
    ┌───┐
    │ 1 │ ← top
    ├───┤
    │ 2 │
    ├───┤
    │ 3 │
    └───┘
    pop() -> 1
```

**操作:**
- `push(item)`: O(1)
- `pop()`: O(1)
- `peek()`: O(1)

**用途:**
- 関数呼び出しスタック
- 括弧のマッチング
- Undo機能
- 深さ優先探索（DFS）

### 4. キュー（Queue）- FIFO

```
    enqueue(1)
    enqueue(2)
    enqueue(3)

    [1] <- [2] <- [3]
    ↑front        ↑rear

    dequeue() -> 1
```

**操作:**
- `enqueue(item)`: O(1)
- `dequeue()`: O(1)
- `peek()`: O(1)

**用途:**
- タスクスケジューリング
- 幅優先探索（BFS）
- バッファ管理

### 5. ハッシュマップ（HashMap）

#### **ハッシュ関数:**
異なる入力値を、同じ長さの値に変換する関数のこと  
```rust
  fn simple_hash(s: &str) -> usize {
      let mut hash = 0;
      for (i, ch) in s.chars().enumerate() {
          hash += (ch as usize) * (31_usize.pow(i as u32));
      }
      return hash;
  }

  fn main() {
    println!("{}", simple_hash("test_string")); // 87422868327719646
  }
```

同じ入力に対しては同じハッシュ値となる  
異なる入力に対して同じハッシュ値（＝ハッシュの衝突）

```
内部では key がハッシュ化されて配列のインデックスとなる
"apple" → 12345 → 12345 % capacity → bucket_index
```

**衝突解決法:**
1. **チェイニング**: 各バケットに連結リストを持つ
2. **オープンアドレッシング**: 別の空きスロットを探す

**計算量:**
- 挿入: 平均 O(1)、最悪 O(n)
- 探索: 平均 O(1)、最悪 O(n)
- 削除: 平均 O(1)、最悪 O(n)

#### **暗号学的ハッシュ**
セキュリティ要件を満たすハッシュ関数  

```rust
use sha2::{Sha256, Digest};

fn main() {
    let mut hasher = Sha256::new();
    hasher.update(b"hello world");
    let result = hasher.finalize();

    println!("{:x}", result); // b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
}
```
出力はアルゴリズムにより可変
SHA-256 -> 256bit -> 32byte -> 64文字の16進数  

** ハッシュ値から入力値を復元できない理由**
- データ圧縮により情報が欠損している
- 複数の入力値が同じ出力値になりうる
- 数学的な制約（逆関数が存在しない）

**対衝突性**
異なる入力値が同じ出力値になるようなペアを見つけることが困難  
※ただしアルゴリズムによる(MD5は衝突可能性あり)  

**雪崩効果**
入力1ビットの変化で、出力50%のビットが変化する  

**SHA-2５６アルゴリズムの内部構造**

1.前処理（padding）  
元のメッセージ: "hello" (長さ 40 ビット = 5byte)

1.1. 元のメッセージ（bit） 01101000 01100101 01101100 01101100 01101111
1.2. "1" を追加 10000000
1.3. ゼロで埋める 00000000 00000000 ...
1.4. 長さを追加 00000000 00000000 00000000 00101000 (40 ビット = 0x28)

最終的に 512 ビット（64バイト）の倍数にする. 
これにより、、、
- メッセージを固定長のブロックに分割可能
- 長さ情報を含めることで、異なる長さのメッセージの衝突を防ぐ  

2.初期ハッシュ値  
SHA-256は8つの32ビット定数から始まる  

```rust
  let H0: u32 = 0x6a09e667;  // sqrt(2) の小数部分
  let H1: u32 = 0xbb67ae85;  // sqrt(3)
  let H2: u32 = 0x3c6ef372;  // sqrt(5)
  let H3: u32 = 0xa54ff53a;  // sqrt(7)
  let H4: u32 = 0x510e527f;  // sqrt(11)
  let H5: u32 = 0x9b05688c;  // sqrt(13)
  let H6: u32 = 0x1f83d9ab;  // sqrt(17)
  let H7: u32 = 0x5be0cd19;  // sqrt(19)
```

**素数の平方根の小数部分を使う理由**
- 恣意性の排除
- バックドアがないことの証明

3.ラウンド定数
64個の定数（最初の64個の素数の立方根）
```rust
const K: [u32; 64] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    // ... 56 個続く
  ];
```

4.メッセージスケジュール
512ビットのブロックを64個の32ビットワードに展開

W[0..15]  = メッセージブロックをそのまま使用
W[16..63] = 前のワードから計算で生成

W[t] = σ1(W[t-2]) + W[t-7] + σ0(W[t-15]) + W[t-16];
＊σ0,σ1はビット操作する関数

```rust
fn sigma0(x: u32) -> u32 { 
    x.rotate_right(7) ^ x.rotate_right(8) ^ (x >> 3)
}

fn sigma1(x: u32) -> u32 {
    x.rotate_right(17) ^ x.rotate_right(19) ^ (x >> 10)
}
```
5.圧縮関数
64ラウンドの処理を繰り返す. 
各ラウンドt(0 <= t < 64). 
    T1 = h + Σ1(e) + ch(e,f,g) + k[t] + W[t]
    T2 = Σ0(a) + Maj(a,b,c)

    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2

```rust
// choose: e が 1 なら f を、0 なら g を選択
fn ch(x: u32, y: u32, z: u32) -> u32 {
    (x & y) ^ (!x & z)
}

// majority: 多数決
fn maj(x: u32, y: u32, z: u32) -> u32 {
    (x & y) ^ (x & z) ^ (y & z)
}

// Σ0,1 ビット開店と XOR の組み合わせ
fn big_sigma0(x: u32) -> u32 {
    x.rotate_right(2) ^ x.rotate_right(13) ^ x.rotate_right(22)
}

fn big_sigma1(x: u32) -> u32 {
    x.rotate_right(6) ^ x.rotate_right(11) ^ x.rotate_right(25)
}

```

6.最終出力
64ラウンド後、初期ハッシュ値に加算

H0 = H0 + a
H1 = H1 + b
H2 = H2 + c
H3 = H3 + d
H4 = H4 + e
H5 = H5 + f
H6 = H6 + g
H7 = H7 + h

// 最終的なハッシュ値
hash = H0 || H1 || H2 || H3 || H4 || H5 || H6 || H7

視覚化：SHA-256 の処理フロー

  入力メッセージ: "hello world"
       ↓
  ┌────────────────────────┐
  │  1. パディング           │  → 512ビットの倍数に
  └────────────────────────┘
       ↓
  ┌────────────────────────┐
  │  2. ブロック分割         │  → 512ビットずつ
  └────────────────────────┘
       ↓
  ┌────────────────────────┐
  │  3. 初期値設定           │  → H0..H7 (8つの定数)
  └────────────────────────┘
       ↓
  ┌────────────────────────┐
  │  各ブロックに対して:      │
  │  - メッセージスケジュール  │  → W[0..63] 生成
  │  - 64ラウンドの圧縮       │  → ビット演算の繰り返し
  │  - ハッシュ値更新         │  → H0..H7 を更新
  └────────────────────────┘
       ↓
  最終ハッシュ値: b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9

## 💻 実装課題

### 課題1: 動的配列（Vec）の簡易実装

`MyVec<T>`を実装してください。以下の機能を含む:
- `new()`: 新しい空のベクターを作成
- `push(item)`: 要素を追加
- `pop()`: 最後の要素を削除して返す
- `get(index)`: インデックスで要素を取得
- `len()`: 要素数を返す
- `drop()`: ベクターを削除

**ポイント:**
- 容量が足りなくなったら2倍に拡張
- `Box<[T]>`や生ポインタを使う
- ドロップ時のメモリ解放を忘れない

### 課題2: 単方向連結リスト

`LinkedList<T>`を実装してください:
- `new()`: 新しいリストを作成
- `push_front(item)`: 先頭に追加
- `push_back(item)`: 末尾に追加
- `pop_front()`: 先頭から削除
- `len()`: 要素数を返す
- `iter()`: イテレータを返す

**ポイント:**
- `Box<Node<T>>`を使う
- 再帰的なデータ構造に注意

### 課題3: スタックの実装

`Stack<T>`を実装してください:
- `new()`: 新しいスタックを作成
- `push(item)`: 要素を追加
- `pop()`: 要素を削除して返す
- `peek()`: トップの要素を参照
- `is_empty()`: 空かどうか判定

**応用問題:**
- 括弧のバランスチェッカーを実装
- 逆ポーランド記法（RPN）計算機を実装

### 課題4: キューの実装

`Queue<T>`を実装してください:
- `new()`: 新しいキューを作成
- `enqueue(item)`: 要素を追加
- `dequeue()`: 要素を削除して返す
- `peek()`: 先頭の要素を参照
- `is_empty()`: 空かどうか判定

**ポイント:**
- `VecDeque`を使わず、自分で実装
- リングバッファの実装に挑戦

### 課題5: シンプルなハッシュマップ

`SimpleHashMap<K, V>`を実装してください:
- `new()`: 新しいハッシュマップを作成
- `insert(key, value)`: キーと値を挿入
- `get(key)`: キーで値を取得
- `remove(key)`: キーを削除
- `contains_key(key)`: キーの存在確認

**ポイント:**
- チェイニングで衝突を解決
- 負荷率が0.75を超えたらリサイズ
- 簡単なハッシュ関数を実装（例: 文字コードの合計）

## 🧪 テストケース例

各実装には以下のようなテストを書いてください:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec_push_and_pop() {
        let mut vec = MyVec::new();
        vec.push(1);
        vec.push(2);
        vec.push(3);

        assert_eq!(vec.len(), 3);
        assert_eq!(vec.pop(), Some(3));
        assert_eq!(vec.pop(), Some(2));
        assert_eq!(vec.len(), 1);
    }

    #[test]
    fn test_vec_capacity_growth() {
        let mut vec = MyVec::new();
        let initial_capacity = vec.capacity();

        for i in 0..initial_capacity + 1 {
            vec.push(i);
        }

        assert!(vec.capacity() > initial_capacity);
    }
}
```

## 🔍 デバッグのヒント

1. **所有権エラー**: 借用チェッカーと戦う場合は、`Rc`や`RefCell`の使用を検討
2. **メモリリーク**: `cargo test`の後に`valgrind`（またはRustの`miri`）で確認
3. **パフォーマンス**: `cargo bench`でベンチマークを取る

## 📖 追加学習リソース

- [Learning Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/)
- [The Rustonomicon](https://doc.rust-lang.org/nomicon/) - Unsafe Rustについて
- [std::collections のドキュメント](https://doc.rust-lang.org/std/collections/)

## ✅ チェックリスト

- [ ] MyVec の基本機能を実装
- [ ] MyVec のテストをすべてパス
- [ ] LinkedList を実装
- [ ] LinkedList のイテレータを実装
- [ ] Stack を実装し、括弧チェッカーを作成
- [ ] Queue を実装
- [ ] SimpleHashMap を実装
- [ ] すべてのテストが通る
- [ ] 各データ構造の計算量を理解した
- [ ] どの状況でどのデータ構造を使うべきか説明できる

## 🚀 次のステップ

Week 1-2が完了したら、Week 3-4の探索とソートアルゴリズムに進みましょう！
